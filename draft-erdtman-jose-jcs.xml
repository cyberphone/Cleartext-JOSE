<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="info" docName="draft-erdtman-jose-jcs-00" ipr="trust200902">
 <front>
   <title abbrev="draft-erdtman-jose-jcs">
     JSON Cleartext Signature (JCS)
   </title>

   <author fullname="Anders Rundgren" initials="A." surname="Rundgren">
     <organization>Independent</organization>
     <address>
       <postal>
         <street></street>
         <code></code> <city></city>
         <country>France</country>
       </postal>
       <email>anders.rundgren.net@gmail.com</email>
     </address>
   </author>

   <author fullname="Samuel Erdtman" initials="S." surname="Erdtman">
     <organization>Spotify AB</organization>
     <address>
       <postal>
         <street>Birger Jarlsgatan 61, 4tr</street>
         <code>113 56</code> <city>Stockholm</city>
         <country>Sweden</country>
       </postal>
       <email>erdtman@spotify.com</email>
     </address>
   </author>

   <date year="2017" />

   <area>Security</area>

   <workgroup>Javascript Object Signing and Encryption</workgroup>

   <keyword>
     JOSE, Signing, Encryption, Cleartext
   </keyword>

   <abstract>
     <t>
       JCS is a scheme for signing data expressed as cleartext JSON
       <xref target="RFC7159"/> objects, the signature is enveloped in the JSON
       object to be signed. JCS builds on JWS <xref target="RFC7515"/>, JWA
       <xref target="RFC7518"/> and JWK <xref target="RFC7517"/> for most
       parts, e.g. headers, algorithms and key packaging. Serialization of the
       JSON object to be signed depends on the introduction of predictable
       Serialization in ECMAScript version 6 <xref target="ES6"/>.
     </t>
   </abstract>
 </front>

<middle>
  <section title="Introduction">
    <t>
      JCS is a scheme for signing data expressed as cleartext JSON
      objects, the signature is enveloped in the JSON object to be signed. By
      enveloping the signature in the JSON object to be signed it is easy
      inspect data in transit and when archived integrity can be guaranteed.
    </t>
    <t>
      For most parts JCS reuses the constructs form JWS, JWA and JWK. Headers
      form JWS, algorithms from JWA and the key structure form JWK. There are
      two essential differences from JWS. First JCS signatures are enveloped in
      the signed data. Secondly it depends on predictable JSON Serialization
      instead of ASCII armoring the data to be signed.
    </t>
    <t>
      In the following example there are a few things to note. The signature is
      embedded in the data. The attributes in the signature construct is the JWS
      headers with one add-on, the 'value' attribute which contains the
      base64url encoded signature bytes.
      <figure align="center" anchor="fig:examplesignature" title='JCS signed example'>
  	    <artwork>
<![CDATA[
{
  "iss":"joe",
  "exp":1300819380,
  "http://example.com/is_root":true,
  "signature": {
    "alg": "ES256",
    "jwk": {
      "kty": "EC",
      "crv": "P-256",
      "x": "_gow8fcS3Dx9z6j57U5q8tunnRBdrgLU9A7CZTYCnqU",
      "y": "bdfJGraBVL5aPj38TG4tHwxpU2VKwG1XBp0wQfCLOFQ"
    },
    "value": "aRx2MQyCGVOZGViAC_7bEDUp8_CGO1kU1l7Lvp1FHx4qBiPkGs9Z7TKGK774XLTGwaCfUtd1VrscabQhmArCxA"
  }
}
]]>
        </artwork>
      </figure>
    </t>
  </section>

  <section title="Terminology">
    <t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be interpreted as
      described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
      when, and only when, they appear in all capitals, as shown here.
    </t>
  </section>

  <section anchor="SignatureConstruct" title="The Signature Construct">
    <t>
      The signature attribute that is added to the data is essentially the JWS
      header, but with the additional attribute "value", which contains the
      encoded signature value.
    </t>
    <t>
      When putting the signature construct into the data to be signed it MUST
      be put labeled with a the key "signature", i.e. the object to be signed
      cannot have its own root item that is named "signature" (or "signatures").
    </t>
    <section anchor="SignatureConstructValueAttribute" title="The Value attribute">
      <t>
        This specification registers the new JWS/JWE header "value". The value
        of this attribute contains the base64url-encoded signature as a string.
      </t>
    </section>
  </section>

  <section anchor="ProducingConsumingJCSs" title="Producing and Consuming JCSs">
    <section anchor="MessageSignatureMACComputation" title="Message Signature or MAC Computation">
      <t>
        To create a JSC, the following steps are performed.  The order of the
        steps is not significant in cases where there are no dependencies
        between the inputs and outputs of the steps.
      </t>
      <t>
        <list style="numbers">
          <t>
            Create the JSON object to be signed.
          </t>
          <t>
            Create the signature object with the headers to be used and add it
            as a top level attribute to the object to be signed with the key
            "signature".
          </t>
          <t>
            Serialize the object to be signed using the Serialization and
            normalization rules defined in
            <xref target="Serializationnormalization" />
          </t>
          <t>
            Compute the JSC Signature in the manner defined for the particular
            algorithm being used over the Serialized object to be signed. The
            "alg" (algorithm) Header Parameter MUST be present in the signatuer
            construct, with the algorithm value accurately representing the
            algorithm used to construct the JWS Signature.
          </t>
          <t>
            Add the "value" attribute to the signature object with the encoded
            JCS signature, BASE64URL(JSC Signature).
          </t>
        </list>
      </t>
    </section>
    <section anchor="MessageSignatureMACValidation" title="Message Signature or MAC Validation">
      <t>
        When validating a JCS, the following steps are performed.  The order
        of the steps is not significant in cases where there are no
        dependencies between the inputs and outputs of the steps.  If any of
        the listed steps fails, then the signature or MAC cannot be
        validated.
      </t>
      <t>
        When there are multiple JCS Signature values, it is an application
        decision which of the JCS Signature values must successfully validate
        for the JCS to be accepted.  In some cases, all must successfully
        validate, or the JCS will be considered invalid.  In other cases,
        only a specific JCS Signature value needs to be successfully
        validated.  However, in all cases, at least one JCS Signature value
        MUST successfully validate, or the JCS MUST be considered invalid.
      </t>
      <t>
        <list style="numbers">
          <t>
            Parse JSON data including enveloped signature.
          </t>
          <t>
            Verify that the implementation understands and can process all
            fields that it is required to support, whether required by this
            specification, by the algorithm being used, or by the "crit"
            Header Parameter value, and that the values of those parameters
            are also understood and supported.
          </t>
          <t>
            Save and remove "value" attribute from the signature object and
            base64url-decode the encoded representation of the JCS Signature.
          </t>
          <t>
            Serialize and normalise the signed object including the signature
            object, by following the rules in
            <xref target="Serializationnormalization" />.
          </t>
          <t>
            Validate the JCS Signature against the JCS Signing Input, i.e. the
            Serialized and Normalized data, in the manner defined for the
            algorithm being used, which MUST be accurately represented by the
            value of the "alg" (algorithm) Header Parameter (parameter in
            signature object), which MUST be present. Record whether the
            validation succeeded or not.
          </t>
          <t>
            Return the a result indicating whether or not the JCS was
            successfully validated.
          </t>
          <t>
            For later validation of the signed object put back the "value"
            attribute in the signature.
          </t>
        </list>
      </t>
    </section>
    <section anchor="Serializationnormalization" title="Serialization and normalization">
      <t>
        Rules for (de)serialization of the signed object or object to be signed.
        <list style="symbols">
          <t>
            The original property serialization order MUST be preserved as
            described by ECMAScript <xref target="ES6"/> section 9.1.12.
          </t>
          <t>
            JSON data of the type "Number", MUST be processed according to
            ECMAScript <xref target="ES6"/> section 7.1.12.1.
          </t>
          <t>
            Property names MUST NOT be empty ("").
          </t>
          <t>
            Property names MUST be unique.
          </t>
        </list>
      </t>
      <t>
        Steps to normalise data to be signed or verified.
        <list style="symbols">
          <t>
            The value property must be deleted from the signature object.
          </t>
          <t>
            Whitespace must be removed which in practical terms means removal
            of all characters outside of quoted strings having a value of x09,
            x0a, x0d or x20.
          </t>
          <t>
            JSON '\/' escape sequences within quoted strings must be treated as
            "degenerate" equivalents to '/' by rewriting them.
          </t>
          <t>
            As specified by ECMAScript <xref target="ES6"/> section 24.3.2.2:
            <list style="symbols">
              <t>
                Unicode escape sequences (\uhhhh) within quoted strings must be
                adjusted as follows: If the Unicode value falls within the
                traditional ASCII control character range (0x00 - 0x1f), it must
                be rewritten in lowercase hexadecimal notation unless it is one
                of the predefined JSON escapes (\" \\ \b \f \n \r \t) because
                the latter have precedence. If the Unicode value is outside of
                the ASCII control character range, it must be replaced by the
                corresponding Unicode character.
              </t>
            </list>
          </t>
        </list>
      </t>
      <t>
        When rules has been applied to the example signature it looks like this. The output
        string was folded for improving readability.
        <figure align="center" anchor="fig:NormalizedExample" title='Normalized example'>
          <artwork>
<![CDATA[
{"iss":"joe","exp":1300819380,"http://example.com/is_root":true,
"signature":{"alg":"ES256","jwk":{"kty":"EC","crv":"P-256","x":
"_gow8fcS3Dx9z6j57U5q8tunnRBdrgLU9A7CZTYCnqU","y":"bdfJGraBVL5aP
j38TG4tHwxpU2VKwG1XBp0wQfCLOFQ"}}}
]]>
          </artwork>
        </figure>
      </t>
    </section>
    <section anchor="MultipleSignatures" title="Multiple Signatures">
      <t>
        Multiple signatures enable different keys to independently of each other
        add a signature to a JSON object.
      </t>
      <t>
        The normalization procedure is essentially the same as for single
        signatures but must also take the following in account as well:
        <list style="symbols">
          <t>
            The "signature" property must be "signatures" and contain an array
            of signature constructs.
          </t>
          <t>
            Each signature requires its own normalization process. During this
            process the other signature objects must (temporarily) be removed.
          </t>
        </list>
      </t>
    </section>
  </section>

  <section anchor="SignatureScope" title="Signature Scope">
    <t>
      The scope of a signature, what is actually signed, comprises all
      properties including possible child objects of the JSON object holding
      the signature property except for the "value" property in the signature
      object.
    </t>
  </section>

  <section anchor="IANA" title="IANA Considerations">
    <section anchor="IANAJSONHeaderParametersRegistry" title="JSON Header Parameters Registry">
      <t>
        This section registers the "value" header parameter in the "JSON Web
        Signature and Encryption Header Parameters" registry
        in the manner described in <xref target="RFC7515"/>, which is used to
        hold the signature value of the JCS.
      </t>
      <section anchor="IANAJSONHeaderParametersRegistryContents" title="Registry Contents">
        <t>
          <list style='symbols'>
            <t>Header Parameter Name: <spanx style="verb">value</spanx></t>
            <t>Header Parameter Description: The base64url-encoded signature value.</t>
            <t>Header Parameter Usage Location(s): <spanx style="verb">JCS</spanx></t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="SignatureConstructValueAttribute"/></t>
          </list>
        </t>
      </section>
    </section>
  </section>

  <section anchor="Security" title="Security Considerations">
    <t>
      This specification does (to the author's knowledge), not introduce
      additional vulnerabilities over what is specified for JWS
      <xref target="RFC7515"/>.
    </t>
  </section>

  <section anchor="Acknowledgements" title="Acknowledgements">
    <t>
      This document builds on the work done in JOSE WG so a big thanks goes out
      to all involved in that work. It is specifically inspired by JWS so a
      special thanks to the authors of that document, M. Jones, J. Bradley
      and N. Sakimura.
    </t>
  </section>
 </middle>

 <back>
   <references title="Normative References">
     <?rfc include='reference.RFC.2119'?>
     <?rfc include='reference.RFC.7159'?>
     <?rfc include='reference.RFC.7515'?>
     <?rfc include='reference.RFC.7517'?>
     <?rfc include='reference.RFC.7518'?>
     <?rfc include='reference.RFC.8174'?>

     <reference anchor="ES6" target="https://www.ecma-international.org/ecma-262/6.0/ECMA-262.pdf">
       <front>
         <title>ECMAScript 2015 Language Specification</title>
         <author>
           <organization>Ecma International</organization>
         </author>
         <date/>
       </front>
     </reference>
   </references>

   <section anchor="TestVectors" title="Test Vectors">
     <t>
       TBD
     </t>
   </section>
 </back>
</rfc>
