<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="info" docName="draft-erdtman-jose-cleartext-jwe-00" ipr="trust200902">
 <front>
   <title abbrev="draft-erdtman-jose-cleartext-jwe">
     Cleartext JSON Web Encryption (JWE)
   </title>

   <author fullname="Samuel Erdtman" initials="S." surname="Erdtman">
     <organization>Spotify AB</organization>
     <address>
       <postal>
         <street>Birger Jarlsgatan 61, 4tr</street>
         <code>113 56</code> <city>Stockholm</city>
         <country>Sweden</country>
       </postal>
       <email>erdtman@spotify.com</email>
     </address>
   </author>

   <author fullname="Anders Rundgren" initials="A." surname="Rundgren">
     <organization>Independent</organization>
     <address>
       <postal>
         <street></street>
         <code></code> <city>Montpellier</city>
         <country>France</country>
       </postal>
       <email>anders.rundgren.net@gmail.com</email>
     </address>
   </author>

   <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization abbrev="Microsoft">Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
	<uri>http://self-issued.info/</uri>
      </address>
    </author>

   <date year="2018" />

   <area>Security</area>

   <workgroup>JSON Object Signing and Encryption (JOSE)</workgroup>

   <keyword>
     JOSE, Signing, Encryption, Cleartext
   </keyword>

   <abstract>
     <t>
       Cleartext JSON Web Encryption (JWE) represents encrypted content using JSON data structures.
       With the use of the predictable serialization defined in ECMAScript version 6,
       protected header parameters can remain in cleartext.
       Cleartext JWE reuses data structures and semantics from JWE whenever practical and reasonable.
       Cryptographic algorithms and identifiers used by this specification
       are defined in the JSON Web Algorithms specification.
     </t>
   </abstract>
 </front>

<middle>
  <section anchor="Introduction" title="Introduction">
    <t>
      Cleartext JSON Web Encryption (JWE) represents encrypted content using JSON-based data structures.
      With the use of predictable serialization
      defined in ECMAScript version 6 <xref target="ES6"/> protected header parameters
      can remain cleartext. Cleartext JWE reuses header parameters and most of the processing
      semantics from JWE.
      Cryptographic algorithms and identifiers used by this specification
      are defined in the JSON Web Algorithms (JWA) <xref target="RFC7518" /> specification.
    </t>
    <t>
      By keeping header parameters in cleartext, the structure becomes easier to read.
      However, cleartext header parameters are not suitable for all purposes, e.g.,
      transport as HTTP query parameter is not possible without additional
      encoding.  The following is a summary of Cleartext JWE features:
    </t>
    <t>
       <list style='symbols'>
        <t>
          All Header parameters including <spanx style="verb">encrypted_key</spanx> are protected.
        </t>
        <t>All Header parameters are supplied in clear.</t>
        <t>
          Simple syntax, intended matching an tentative Cleartext JWS counterpart.
        </t>
      </list>
    </t>
  </section>

  <section title="Terminology">
    <t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be interpreted as
      described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
      when, and only when, they appear in all capitals, as shown here.
    </t>
  </section>

  <section anchor="EncryptionStructure" title="Encryption Structure">
    <t>
      This section explains how the encryption structure is formed for the
      different cases available.
    </t>
    <t>
      The outermost layer contains equivalants of the JWE header parameters,
      with the addition of <spanx style="verb">recipients</spanx>, <spanx style="verb">encrypted_key</spanx>, and <spanx style="verb">ciphertext</spanx> members.
    </t>
    <t>
      Recipients has the same usage as in the JWE JSON encoding, but the structure
      is slightly different. Instead of an object with members <spanx style="verb">header</spanx> and
      <spanx style="verb">encrypted_key</spanx>, these have been collapsed.
      The <spanx style="verb">recipients</spanx> array MUST
      only be included when the message is addressed to multiple recipients.
    </t>
    <t>
      The <spanx style="verb">encrypted_key</spanx> member is used in the top-level JSON object when there is only
      one recipient, i.e., the <spanx style="verb">recipients</spanx> array is not present. When multiple
      recipients are targeted, there is one <spanx style="verb">encrypted_key</spanx> value for each of them
      in the <spanx style="verb">recipients</spanx> array.
    </t>
    <t>The Cleartext JWE JSON structure can be illustrated as below:</t>
    <t>
      <figure align="center">
        <artwork>
<![CDATA[{
  <JWE Header Parameters />,
  "recipients": [{
    <JWE Header Parameters />,
    "encrypted_key": "<base64url-encoded data />"
  }],
  "encrypted_key": "<base64url-encoded data />"
  "iv": "<base64url-encoded data />",
  "tag": "<base64url-encoded data />",
  "ciphertext": "<base64url-encoded data />"
}]]></artwork>
      </figure>
    </t>
    <t>
      Depending on the Key Management Mode and number of recipients,
      the structure and members used differs slightly.
    </t>
    <t>The following sub section describes the different modes in more detail.
    All the examples encrypt the data specified in <xref target="testdata"/>.
    Note that in many of the examples JSON strings are sliced due to RFC line
    length constraints.
  </t>
    <section anchor="SingleRecipient" title="Single Recipient">
      <t>
        In the Direct Encryption mode, the parameters <spanx style="verb">alg</spanx> and
        <spanx style="verb">encrypted_key</spanx> are not applicable.
        Since a single recipient is targeted, the <spanx style="verb">recipients</spanx> parameter is not used either.
        If not implied by the context, a <spanx style="verb">kid</spanx> can be used for identifying the CEK.
  The following shows an example of Direct Encryption:
     </t><t>
        <figure align="center">
          <artwork><![CDATA[{
  "enc": "A128CBC-HS256",
  "alg": "dir",
  "kid": "a256bitkey",
  "iv": "RL5u478E9seK-rKFl2JWIw",
  "tag": "FP4DzUJ8eTmH9sWwC5eauQ",
  "ciphertext": "5rdI6-qeuXGSltvckjRC7_bvpFKmPHjO103rkV-Gkdo"
}]]></artwork>
        </figure>
      </t>
      <t>The example can be decrypted using the key in <xref target="a256bitkey"/>.
    </t>
      <t>
        In the Key Encryption mode, a specific key is used to
        encrypt the CEK requiring the <spanx style="verb">alg</spanx> and <spanx style="verb">encrypted_key</spanx> parameters.
        Since a single recipient is targeted, the <spanx style="verb">recipients</spanx> parameter is not used.
        If not implied by the context, a <spanx style="verb">kid</spanx> can be used for identifying the encryption key.
        The following shows an example of Key Encryption using a public key:
      </t>
      <t>
        <figure align="center">
          <artwork><![CDATA[{
  "enc": "A128CBC-HS256",
  "alg": "ECDH-ES+A256KW",
  "kid": "example.com:p256",
  "epk": {
    "kty": "EC",
    "crv": "P-256",
    "x": "kuUDnNijtt6pWyIbKPWN6cM9W8pPRWPj85BJ5TFWyxU",
    "y": "1QqjqwSZSEOYIm55fxtzqKreh9cZyzzWR7LLTnhyXJM"
  },
  "encrypted_key": "rcXxHPcw3r-0s62RbF19BkR19qX6AxX66QSE1ox3hxj9TNqgq
                    nVedQ",
  "iv": "6tZQSbbYAMn1qqLEXiWk9g",
  "tag": "PN-zZwoHWC35a3vW7zWrNw",
  "ciphertext": "cr3ZNcuO7hRWCGEyixCa4xKuOuJhxbLsIzVxHiIeJUQ"
}]]></artwork>
        </figure>
      </t>
      <t>
        The example can be decrypted using the private key in <xref target="example.com:p256"/>.
      </t>
    </section>
    <section anchor="KeyEncryptionExample" title="Multiple Recipients">
      <t>
        Multiple recipients can be addressed with the key management modes Key
        Encryption, Key Wrapping and Key Agreement with Key Wrapping. When
        addressing multiple recipients, the <spanx style="verb">recipients</spanx> array is used. The
        <spanx style="verb">recipients</spanx> array contains a list of objects containing needed header parameters
        and an encrypted CEK (<spanx style="verb">encrypted_key</spanx>).
      </t>
      <t>Header parameters MUST NOT be present at the top level with <spanx style="verb">alg</spanx>
          as the only exception.  In case of the latter arrangement,
          all enclosed encryption constructs MUST use the same algorithm as well as not
          specifying the <spanx style="verb">alg</spanx> Header parameter.
          See <xref target="multipleglobalalg"/> for an example.
        </t>
      <!-- One can imagine a global "crit" but I don't see much use of it and would like
      us to think about it instead... -->
      <t>The following example shows a Cleartext JWE object having multiple recipients:</t>
      <t>
        <figure align="center">
          <artwork><![CDATA[{
  "enc": "A128CBC-HS256",
  "recipients": [{
    "alg": "ECDH-ES+A256KW",
    "kid": "example.com:p256",
    "epk": {
      "kty": "EC",
      "crv": "P-256",
      "x": "zDDhZC9PYlW-1Q7p6NNkO9ivAqQbtPaLURrggjYZM14",
      "y": "0wEmDUfpk1OuwESKLkzZKlN-WSlf3e8ahGqtAAOVJxs"
    },
    "encrypted_key": "M60hnC-Qjjy-vbtHdAUesgweE-9WSKPeksNOXVLVSwiiAac
                      Z_ShXaA"
  },{
    "alg": "RSA-OAEP-256",
    "kid": "example.com:r2048",
    "encrypted_key": "JufGxy4rcyHBBCn4quw6pQxkh2nFFUve7iosQww6pTmv0fM
                      FdzlW02S7u_BTbZ813q67K_rl_yO4ul6T3f4SonA2lIyQnB
                      5FB62bZ5Vr560Mxka9vZ4omuS1hYTOI5ImnZRCeweLaWDe2
                      GRAFmG1z9Ke5_p98g-VBiRml4aPFhEbvRQW-wv2ZKAV5r60
                      CLxcw4FWL7U3TS4iiv_mmSIYCtC7MtBAdaGRpSrVF8MFKjy
                      989xX8I1SvCOHB37MKfs2I6iUBlD1TZMITXtIuoco_zGK3y
                      MLDHuIBwaa1GcEW6g6UNTBv32c25qvrJXepVgCNt1-oxR-I
                      H4xCRPbxaZA6g"
  }],
  "iv": "fX3cL0NTf9KZ71mSJ75QLg",
  "tag": "NbDF8o1gdOJwoA253gbmxw",
  "ciphertext": "gUFN2bXQeiaHIIc48xIWNcJUhHxVxUVhDkdLddb9y1U"
}]]></artwork>
        </figure>
      </t>
      <t>
        The example can be decrypted using the private keys in <xref target="example.com:p256"/>
        and <xref target="example.com:r2048"/>.
      </t>
    </section>
    <section anchor="AdditionalAuthenticatedData" title="Additional Authenticated Data (aad)">
      <t>
        As a difference to JWE JSON representation, Cleartext JWE does not have an
        <spanx style="verb">aad</spanx> member. Since Cleartext JWE integrity protects the whole header parameters
        structure it is recommended that one add additional header parameters to protect
        additional cleartext data that needs to be connected to the ciphertext.
        See JWE section 4.2. (Public Header Parameter Names) and 4.3. (Private
        Header Parameter Names) for details on how to add additional header parameters.
      </t>
    </section>
  </section>

  <section anchor="EncryptingandDecryptingCleartextJWEs" title="Encrypting and Decrypting Cleartext JWEs">
    <section anchor="MessageEncryption" title="Message Encryption">
      <t>
        The message encryption process is as follows.  The order of the steps
        is not significant in cases where there are no dependencies between
        the inputs and outputs of the steps.
      </t>
      <t>
        Most steps are equivalent to the ones in JWE.
	Those that have been changed are indicated as such.
      </t>
      <t>
        <list style="numbers">
          <t>
            Determine the Key Management Mode employed by the algorithm used
            to determine the Content Encryption Key value.  (This is the
            algorithm recorded in the <spanx style="verb">alg</spanx> (algorithm) Header Parameter of
            the resulting JWE.)
          </t>
          <t>
            When Key Wrapping, Key Encryption, or Key Agreement with Key
            Wrapping are employed, generate a random CEK value.  See RFC
            4086 [RFC4086] for considerations on generating random values.
            The CEK MUST have a length equal to that required for the
            content encryption algorithm (<spanx style="verb">enc</spanx>).
          </t>
          <t>
            When Direct Key Agreement or Key Agreement with Key Wrapping are
            employed, use the key agreement algorithm to compute the value
            of the agreed upon key.  When Direct Key Agreement is employed,
            let the CEK be the agreed upon key.  When Key Agreement with Key
            Wrapping is employed, the agreed upon key will be used to wrap
            the CEK.
          </t>
          <t>
            When Key Wrapping, Key Encryption, or Key Agreement with Key
            Wrapping are employed, encrypt the CEK to the recipient and let
            the result be the JWE Encrypted Key (<spanx style="verb">encrypted_key</spanx>).
          </t>
          <t>
            When Direct Encryption is employed, let the CEK be the shared
            symmetric key.
          </t>
          <t>
            Compute the encoded key value BASE64URL(JWE Encrypted Key).
          </t>
          <t>
            If more than one recipient is being addressed, repeat this process
            (steps 1-7) for each recipient.
          </t>
          <t>
            Generate a random JWE Initialization Vector of the correct size
            for the content encryption algorithm (if required for the
            algorithm); otherwise, let the JWE Initialization Vector be the
            empty octet sequence.
          </t>
          <t>
            Compute the encoded Initialization Vector value BASE64URL(JWE
            Initialization Vector).
          </t>
          <t>
            If a <spanx style="verb">zip</spanx> parameter was included, compress the plaintext using
            the specified compression algorithm and let M be the octet
            sequence representing the compressed plaintext; otherwise, let M
            be the octet sequence representing the plaintext.
          </t>
          <t>
            Create the JSON object(s) containing the desired set of Header Parameters,
	    including <spanx style="verb">encrypted_key</spanx> if one recipient is addressed
            or the <spanx style="verb">recipients</spanx> array if more than one recipient is addressed.
            (modified)
          </t>
          <t>
            Serialize the JSON header parameters according to instructions in
            <xref target="Serialization" />. (modified)
          </t>
          <t>
            Let the Additional Authenticated Data encryption parameter be
            the serialized JSON header. (modified)
          </t>
          <t>
            Encrypt M using the CEK, the JWE Initialization Vector, and the
            Additional Authenticated Data value using the specified content
            encryption algorithm to create the JWE Ciphertext value and the
            JWE Authentication Tag (which is the Authentication Tag output
            from the encryption operation).
          </t>
          <t>
            Compute the encoded ciphertext value BASE64URL(JWE Ciphertext).
          </t>
          <t>
            Compute the encoded Authentication Tag value BASE64URL(JWE
            Authentication Tag).
          </t>
          <t>
            Finalize the encryption by adding the JWE Initialization Vector,
            JWE Authentication Tag and JWE Ciphertext to the JSON
            header parameters and let this be the encrypted package. (modified)
          </t>
        </list>
      </t>
    </section>
    <section anchor="MessageDecryption" title="Message Decryption">
      <t>
        The message decryption process is the reverse of the encryption
        process.  The order of the steps is not significant in cases where
        there are no dependencies between the inputs and outputs of the
        steps.  If any of these steps fail, the encrypted content cannot be
        validated.
      </t>
      <t>
        When there are multiple recipients, it is an application decision
        which of the recipients' encrypted content must successfully validate
        for the Cleartext JWE to be accepted.  In some cases, encrypted content for all
        recipients must successfully validate or the Cleartext JWE will be considered
        invalid.  In other cases, only the encrypted content for a single
        recipient needs to be successfully validated.  However, in all cases,
        the encrypted content for at least one recipient MUST successfully
        validate or the Cleartext JWE MUST be considered invalid.
      </t>
      <t>
        Most steps are equivalent to the ones in JWE. Those that has been 
        changed or removed are indicated as such. This is a temporary solution
        to make it easy to spot the difference between JWE and Cleartext JWE,
        It will be removed in final version.
      </t>
      <t>
        <list style="numbers">
          <t>
            Parse the Cleartext JWE JSON structure. (modified)
          </t>
          <t>
            Extract and remove Cleartext JWE components JWE Initialization Vector (<spanx style="verb">iv</spanx>),
            JWE Ciphertext (<spanx style="verb">ciphertext</spanx>) and JWE Authentication Tag (<spanx style="verb">tag</spanx>).
            Let the remaining JSON be the JWE Protected Header. (added)
          </t>
          <t>
            Base64url decode the encoded representations of the JWE Encrypted
            Key, the JWE Initialization Vector, the JWE Ciphertext, and the
            JWE Authentication Tag, following the restriction that no line
            breaks, whitespace, or other additional characters have been
            used.  (modified)
          </t>
          <t>
            Verify that the... (removed, JWE step not needed for Cleartext JWE)
          </t>
          <t>
            Let the JOSE Header be the union of the members of the JWE
            Protected Header and the corresponding JWE Per-Recipient Header.
            During this step, verify that the resulting JOSE Header does not
            contain duplicate Header Parameter names.  This restriction includes
            that the same Header Parameter name also MUST NOT occur in distinct
            JSON object values that together comprise the JOSE Header.
            (modified)
          </t>
          <t>
            Verify that the implementation understands and can process all
            fields that it is required to support, whether required by this
            specification, by the algorithms being used, or by the <spanx style="verb">crit</spanx>
            Header Parameter value, and that the values of those parameters
            are also understood and supported.
          </t>
          <t>
            Determine the Key Management Mode employed by the algorithm
            specified by the <spanx style="verb">alg</spanx> (algorithm) Header Parameter.
          </t>
          <t>
            Verify that the Cleartext JWE uses a key known to the recipient.
          </t>
          <t>
            When Direct Key Agreement or Key Agreement with Key Wrapping are
            employed, use the key agreement algorithm to compute the value
            of the agreed upon key.  When Direct Key Agreement is employed,
            let the CEK be the agreed upon key.  When Key Agreement with Key
            Wrapping is employed, the agreed upon key will be used to
            decrypt the JWE Encrypted Key.
          </t>
          <t>
            When Key Wrapping, Key Encryption, or Key Agreement with Key
            Wrapping are employed, decrypt the JWE Encrypted Key to produce
            the CEK.  The CEK MUST have a length equal to that required for
            the content encryption algorithm.  Note that when there are
            multiple recipients, each recipient will only be able to decrypt
            JWE Encrypted Key values that were encrypted to a key in that
            recipient's possession.  It is therefore normal to only be able
            to decrypt one of the per-recipient JWE Encrypted Key values to
            obtain the CEK value.  Also, see JWE Section 11.5 for security
            considerations on mitigating timing attacks.
          </t>
          <t>
            When Direct Key Agreement or Direct Encryption are employed, verify
            that the JWE Encrypted Key value is absent.
          </t>
          <t>
            When Direct Encryption is employed, let the CEK be the shared
            symmetric key.
          </t>
          <t>
            Record whether the CEK could be successfully determined for this
            recipient or not.
          </t>
          <t>
            If the more than one recipient is addressed, repeat this process
            (steps 4-12) for each recipient contained in the representation.
          </t>
          <t>
            Serialize the JWE Protected Header according to instructions in
            <xref target="Serialization" />. (modified)
          </t>
          <t>
            Let the Additional Authenticated Data encryption parameter be
            the serialized the JWE Protected Header. (modified)
          </t>
          <t>
            Decrypt the JWE Ciphertext using the CEK, the JWE Initialization
            Vector, the Additional Authenticated Data value, and the JWE
            Authentication Tag (which is the Authentication Tag input to the
            calculation) using the specified content encryption algorithm,
            returning the decrypted plaintext and validating the JWE
            Authentication Tag in the manner specified for the algorithm,
            rejecting the input without emitting any decrypted output if the
            JWE Authentication Tag is incorrect.
          </t>
          <t>
            If a <spanx style="verb">zip</spanx> parameter was included, uncompress the decrypted
            plaintext using the specified compression algorithm.
          </t>
          <t>
            If there was no recipient for which all of the decryption steps
            succeeded, then the Cleartext JWE MUST be considered invalid.  Otherwise,
            output the plaintext.  With multiple recipients, also
            return a result to the application indicating for which of the
            recipients the decryption succeeded and failed. (modified)
          </t>
          <t>
            If the JSON data structure needs to be verified later, put back the JWE
            Initialization Vector (<spanx style="verb">iv</spanx>), JWE Ciphertext (<spanx style="verb">ciphertext</spanx>) and
            JWE Authentication Tag (<spanx style="verb">tag</spanx>) into the JWE Protected Header.
          </t>
        </list>
      </t>
      <t>
        Finally, note that it is an application decision which algorithms may
        be used in a given context.  Even if a Cleartext JWE can be successfully
        decrypted, unless the algorithms used in the JWE are acceptable to
        the application, it SHOULD consider the Cleartext JWE to be invalid.
      </t>
    </section>
    <section anchor="Serialization" title="Serialization and Normalization">
      <t>
        When having header parameters in cleartext serialization of them needs to be
        consistent across platforms. JSON <xref target="RFC8259" /> by itself does not produce
        predictable serialization of data. However, ES6 <xref target="ES6"/> defines how to produce
        JSON that is predictable. By following the ES6 serialization directives,
        one can get predictable results, i.e., the JSON serializer MUST follow the
        directives set out by ES6 when serializing data. The rules defined below
        take the essence from the ES6 specification and list what that means
        in practical terms.
      </t>
      <t>
        Rules for serialization:
        <list style="symbols">
          <t>
            The original property serialization order MUST be preserved as
            described by ECMAScript section 9.1.12.
          </t>
          <t>
            JSON data of the type <spanx style="verb">Number</spanx>, MUST be processed according to
            ECMAScript section 7.1.12.1.
          </t>
          <t>
            Property names MUST be unique.
          </t>
          <t>
            Whitespace must be removed which in practical terms means removal
            of all characters outside of quoted strings having a value of x09,
            x0a, x0d or x20.
          </t>
          <t>
            JSON '\/' escape sequences within quoted strings must be treated as
            "degenerate" equivalents to '/' by rewriting them.
          </t>
          <t>
            Unicode escape sequences (\uhhhh) within quoted strings must be
            adjusted as follows: If the Unicode value falls within the
            traditional ASCII control character range (0x00-0x1f and 0x7f), it must
            be rewritten in lowercase hexadecimal notation unless it is one
            of the predefined JSON escapes (\" \\ \b \f \n \r \t) because
            the latter have precedence. If the Unicode value is outside of
            the ASCII control character range, it must be replaced by the
            corresponding Unicode character. See ECMAScript section 24.3.2.2.
          </t>
        </list>
      </t>
      <t>
        If these rules are applied to the public key encryption example in <xref target="SingleRecipient"/>, it should result in
        the following string
        (with line wraps within values for display purposes only):
      </t>
      <t>
        <figure align="center">
          <artwork><![CDATA[{"enc":"A128CBC-HS256","alg":"ECDH-ES+A256KW","kid":"example.com:
p256","epk":{"kty":"EC","crv":"P-256","x":"kuUDnNijtt6pWyIbKPWN6c
M9W8pPRWPj85BJ5TFWyxU","y":"1QqjqwSZSEOYIm55fxtzqKreh9cZyzzWR7LLT
nhyXJM"},"encrypted_key":"rcXxHPcw3r-0s62RbF19BkR19qX6AxX66QSE1ox
3hxj9TNqgqnVedQ","iv":"6tZQSbbYAMn1qqLEXiWk9g"}]]></artwork>
        </figure>
      </t>
    </section>
    <section anchor="ES6Interoperability" title="ES6+ Interoperability">
      <t>
        For JavaScript optimization reasons, ES6+'s JSON.parse() internally
        rearranges the order of properties with names expressed as integers, making a
        parsed JSON string like '{"2":"First", "A":"Second","1":"Third"}' actually serialize as
        '{"1":"Third","2":"First","A":"Second"}'. Due to this fact, signature creators MUST
        "emulate" this scheme since this behavior is not
        intended to be an additional requirement to support by JSON tools in
        general in order to use this specification.   The easiest way
        accomplishing this is to programmatically make sure that possible
        numeric property names always are created first and added in ascending
        order.
      </t>
    </section>
  </section>

  <section anchor="IANA" title="IANA Considerations">
    <section anchor="IANAJSONHeaderParametersRegistry" title="JSON Header Parameters Registry">
      <t>
        This section registers "ciphertext", "encrypted_key" and "recipients"
        header parameters in the "JSON Web Signature and Encryption Header
        Parameters" registry in the manner described in <xref target="RFC7516"/>.
      </t>
      <section anchor="IANAJSONHeaderParametersRegistryContents" title="Registry Contents">
        <t>
          <list style='symbols'>
            <t>Header Parameter Name: <spanx style="verb">ciphertext</spanx></t>
            <t>Header Parameter Description: The base64url-encoded ciphertext</t>
            <t>Header Parameter Usage Location(s): <spanx style="verb">CT-JWE</spanx></t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): [this document]</t>
          </list>
        </t>
        <t>
          <list style='symbols'>
            <t>Header Parameter Name: <spanx style="verb">encrypted_key</spanx></t>
            <t>Header Parameter Description: The base64url-encoded encrypted CEK</t>
            <t>Header Parameter Usage Location(s): <spanx style="verb">CT-JWE</spanx></t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): [this document]</t>
          </list>
        </t>
        <t>
          <list style='symbols'>
            <t>Header Parameter Name: <spanx style="verb">recipients</spanx></t>
            <t>Header Parameter Description: List of targeted recipients, each with a set of headers</t>
            <t>Header Parameter Usage Location(s): <spanx style="verb">CT-JWE</spanx></t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): [this document]</t>
          </list>
        </t>
      </section>
    </section>
  </section>

  <section anchor="Security" title="Security Considerations">
    <t>
      This specification does (to the authors' knowledge), not introduce
      additional vulnerabilities over what is specified for JWE
      <xref target="RFC7516"/>.
    </t>
  </section>

  <section anchor="Acknowledgements" title="Acknowledgements">
    <t>
      This document builds on the work done in the JOSE WG so a big thanks goes out
      to all involved in that work. It is specifically inspired by JWE, so a
      special thanks to the authors of that document, Michael B. Jones and
      Joe Hildebrand.
    </t>
    <t>
      Building on ES6 number normalization was originally
      proposed by James Manger. This ultimately led to
      the adoption of the entire ES6 JSON processing model.
    </t>
  </section>
 </middle>

 <back>
   <references title="Normative References">
     <?rfc include='reference.RFC.2119'?>
     <?rfc include='reference.RFC.8259'?>
     <?rfc include='reference.RFC.7516'?>
     <?rfc include='reference.RFC.7518'?>
     <?rfc include='reference.RFC.8174'?>

     <reference anchor="ES6" target="https://www.ecma-international.org/ecma-262/6.0/ECMA-262.pdf">
       <front>
         <title>ECMAScript 2015 Language Specification</title>
         <author>
           <organization>Ecma International</organization>
         </author>
         <date/>
       </front>
     </reference>
   </references>

   <section anchor="TestVectors" title="Test Vectors">
     <t>
       This section contains a set of test vectors sharing a common characteristic,
       long lines are sliced in order to cope with RFC line length constraints.
     </t>
     <section anchor="testdata" title="Common Data to Encrypt">
       <t>All examples in this specification encrypt the plaintext:
         &quot;Hello encrypted world!&quot;.
       Expressed as decimal bytes this yields:</t>
       <t>
         72, 101, 108, 108, 111, 32, 101, 110, 99,
         114, 121, 112, 116, 101, 100, 32, 119, 111,
         114, 108, 100, 33
       </t>
     </section>
     <section anchor="a256bitkey" title="Symmetric Key &quot;a256bitkey&quot;">
       <t>256-bit symmetric key, here expressed in hexadecimal notation:</t>
       <t>
         <figure align="center">
           <artwork>7fdd851a3b9d2dafc5f0d00030e22b9343900cd42ede4948568a4a2ee655291a</artwork>
         </figure>
       </t>
     </section>
     <section anchor="example.com:p256" title="EC Key &quot;example.com:p256&quot;">
       <t>EC private key, here expressed in JWK notation:</t>
       <t>
         <figure align="center">
           <artwork><![CDATA[{
  "kid": "example.com:p256",
  "kty": "EC",
  "crv": "P-256",
  "x": "censDzcMEkgiePz6DXB7cDuwFemshAFR90UNVQFCg8Q",
  "y": "xq8rze6ewG0-eVcSF72J77gKiD0IHnzpwHaU7t6nVeY",
  "d": "nEsftLbi5u9pI8B0-drEjIuJzQgZie3yeqUR3BwWDl4"
}]]></artwork>
         </figure>
       </t>
     </section>
     <section anchor="example.com:p384" title="EC Key &quot;example.com:p384&quot;">
       <t>EC private key, here expressed in JWK notation:</t>
       <t>
         <figure align="center">
           <artwork><![CDATA[{
  "kid": "example.com:p384",
  "kty": "EC",
  "crv": "P-384",
  "x": "GLfdsvEwphRzS_twup7UFPVOk7_CKgHZ7dt_fJ2QHPBdJa1c5pfJcRIWTfT0l
        pg9",
  "y": "ovA5_QXmFbj9U4pjZ1AX_ZdVyIRZUBWW9cuZda_tupKfWQfmcQHzDmHGHbxl9
        Xxl",
  "d": "Qsgq80kMs40sAn1gB7gLxAk1se37Kmh9AG18wWZ3SqgcPPRq1wwidNTi866Gt
        4_0"
}]]></artwork>
         </figure>
       </t>
     </section>
     <section anchor="example.com:r2048" title="RSA Key &quot;example.com:r2048&quot;">
       <t>RSA private key, here expressed in JWK notation:</t>
       <t>
         <figure align="center">
           <artwork><![CDATA[{
  "kid": "example.com:r2048",
  "kty": "RSA",
  "n": "hFWEXArvaZEpSP5qNX7x4C4Hl28GJQTNvnDwkfqiWs63kXbdyPeS06bz6GnY3
        tfQ_093nGauWsimqKBmGAGMPtsV83Qxw1OIeO4ujbIIb9pema0qtVqs0MWlHx
        klZGFkYfAmbuEUFxYDeLDHe0bkkXbSlB7_t8pCSvc8HLgHjEQjYOlFRwjR0D-
        uLo-xgsCbpmCtYkB5lcT_zFgpRgY4zJNLSv7GZiz2S4Fc5ArGjd34lL47-L8b
        ozuYjqNOv9sqX0Zgll5XaJ1ndvr7UqZu1xQFgm38reoM3IarBP_SkEFbt_v9i
        ak602VO3k28fQhMaocP7JWR2YLT3kZM0-WTFw",
  "e": "AQAB",
  "d": "Q6iBYpnIrB2mkQZagP1lZuvBv9_osVaSZpLRvKD7DxhvbDTs0coaTJIoVCSB1
        _VZip8zlUg-TnYWF1Liv9VSwfQ7ddxrcOUtej60mId0ntNz2HhbxJsWjiru8E
        ZoArl0nEovLDNxlRgRMEyZwOKPC_xHT6nFrk7_s9pR5pEEcubGLAVBKnLCoPd
        Lr-CBjCvWfJo73W5AZxoSb8MdWQOi5viXHURpr1Y_uBRsMuclovM56Vt05etM
        sB1AbcTLUDwAuYrZWa1c08ql60ft7b3v6Q_rCL7EHtFU3PHAuP0mV7tM5BfAP
        f4T0g9pbr4GOw7eqQCiYgPFE7gmCR_PDxv5YQ",
  "p": "6DIM343hAtj1hQprJaVQ3T8YeIytIQ7Ma544C0A8BX-irjJfARy4fAlTSyBFe
        auZ0WdbMGtKpAIgNVmfCfuP7W1bXw7UaxpqsQlbw54K1VtBs8xG-lee_2YQ3l
        UlIiC1at6L0jxWYNkvp-LIfU2F5ZQir5ZWVXwgdMcgoNBABMc",
  "q": "keacq0goV7pAtG2h33OAk-XOSclIF1agvEMMOKuud5V-vGQ6OaYldlYqZmSGg
        F7RVlX0GZO70nPqatjd2G-tI8wEq5K_xmLQurUPFW8g___z0CTgJ62KbjFxCt
        Gny5rsObX9im6cCc_EOtWZRaApzO8ykxfo1QcEjT4k1na7DzE",
  "dp": "nPmJPnFal2Q5x_GdMlwq6QhI8OaZ_OlWRcM3PFP2v_jj8ERZehUCm8hqKTXu
         Ai2C1dC8E2XVlj9hqu-l10fcq7Tsurz52laHnpwnD35-8HK7XmRR79jgwuUr
         rkN90S6vt0ow2La15s-tqiBlTmDkjqqxMGfAghZiktA0PMPNI-0",
  "dq": "D3c1lkZw2FPK9hVE-m3A7GyIwHOQq8CoCyzER-GS_eQf6hJpxaCiCfg6SF5R
         j5v9brxvwqJRX46gA7F3WrED1m6S9Cj7ISlqXNBCiBAenGRiUOcHx8zyhpnB
         FNeChOeoMLnk5V6yNawLbf0kYSgIJkwYvVTkfmhfCCXVO9KcI5E",
  "qi": "wV0NzfCakfog1NFjtPzcga1MtkpizgPkxcP9LjNdvXW2YQZhM6GIEGjsu3iv
         TrHrrM-4_bTQHOoTtfIY7wdqBKlwQTJOI0dH9FbNJ4ecGojRwgv83TN8aNKh
         17Tt44jI5oibs2P-31B_VW9R1wwhnnOuCYpABfoSbtHIoCRme5I"
}]]></artwork>
         </figure>
       </t>
     </section>
     <section anchor="multipleglobalalg" title="Multiple Recipients with Global &quot;alg&quot; Header">
       <t>
         <figure align="center">
           <artwork><![CDATA[{
  "enc": "A128CBC-HS256",
  "alg": "ECDH-ES+A256KW",
  "recipients": [{
    "kid": "example.com:p256",
    "epk": {
      "kty": "EC",
      "crv": "P-256",
      "x": "43RpNrzkVJYkQzy38iCLIzkaksDex1s6MOuciPCK-k0",
      "y": "QKU2l4MF1ak7ouucCcp59fha0q5pcOk3WXyXs-O6LiI"
    },
    "encrypted_key": "aMXF6e_7xLWzKgXTslyNyx8SZ0ODpZTrlFA5z1KAr6unZER
                      F353dsQ"
  },{
    "kid": "example.com:p384",
    "epk": {
      "kty": "EC",
      "crv": "P-384",
      "x": "gDPrpkig_99ii2HfqWPwHz-WIr2xRbqwXFfKIw57MdnD2NDI-hs-w-e0
            GM1vMAVH",
      "y": "8O7mAfCT1QKlE66u2EMCvAue85b5s2pVlW7rpZ7YDwNUOg6C1FsQvadS
            Qyrod6lJ"
    },
    "encrypted_key": "r3Ze98xdCvOGFVnxhahs6H0NHSRmD44lTzbvNUootJ8VFqy
                      mt-ZLSg"
  }],
  "iv": "N4tuF0C6an86-OLF-G9cMg",
  "tag": "SGT7Znl2TOIB4UjbJQzyvg",
  "ciphertext": "nt0c3g52uCCl_vS_kJWZTepayHPiM89GjZey6YNoaDM"
}]]></artwork>
         </figure>
       </t>
       <t>
         The example can be decrypted using the private keys in <xref target="example.com:p256"/>
         and <xref target="example.com:p384"/>.
       </t>
     </section>
   </section>
 </back>
</rfc>
